// Generated by Scapix Java API 2.0
// https://www.scapix.com

#include <scapix/java_api/java/lang/Object.h>

#ifndef SCAPIX_JAVA_API_ANDROID_TEXT_TEXTUTILS_FWD
#define SCAPIX_JAVA_API_ANDROID_TEXT_TEXTUTILS_FWD

#include <scapix/jni/java_api/macros_push.h>

namespace scapix::java_api::android::text { class TextUtils; }

template<>
struct scapix::jni::object_traits<scapix::java_api::android::text::TextUtils>
{
	static constexpr fixed_string class_name = "android/text/TextUtils";
	using base_classes = std::tuple<scapix::java_api::java::lang::Object>;
};

#include <scapix/jni/java_api/macros_pop.h>

#endif // SCAPIX_JAVA_API_ANDROID_TEXT_TEXTUTILS_FWD

#if !defined(SCAPIX_JAVA_API_FWD) && !defined(SCAPIX_JAVA_API_ANDROID_TEXT_TEXTUTILS)
#define SCAPIX_JAVA_API_ANDROID_TEXT_TEXTUTILS

#define SCAPIX_JAVA_API_FWD
#include <scapix/java_api/android/content/Context.h>
#include <scapix/java_api/android/os/Parcel.h>
#include <scapix/java_api/android/os/Parcelable_Creator.h>
#include <scapix/java_api/android/text/Spannable.h>
#include <scapix/java_api/android/text/Spanned.h>
#include <scapix/java_api/android/text/TextPaint.h>
#include <scapix/java_api/android/text/TextUtils_EllipsizeCallback.h>
#include <scapix/java_api/android/text/TextUtils_TruncateAt.h>
#include <scapix/java_api/android/util/Printer.h>
#include <scapix/java_api/java/lang/CharSequence.h>
#include <scapix/java_api/java/lang/Class.h>
#include <scapix/java_api/java/lang/Iterable.h>
#include <scapix/java_api/java/lang/String.h>
#include <scapix/java_api/java/util/List.h>
#include <scapix/java_api/java/util/Locale.h>
#include <scapix/java_api/java/util/regex/Pattern.h>
#include <scapix/java_api/android/text/TextUtils_StringSplitter.h>
#include <scapix/java_api/android/text/TextUtils_SimpleStringSplitter.h>
#undef SCAPIX_JAVA_API_FWD

#include <scapix/jni/java_api/macros_push.h>

namespace scapix::java_api {

class android::text::TextUtils : public jni::object_base<"android/text/TextUtils",
	java::lang::Object>
{
public:

	using TruncateAt = TextUtils_TruncateAt;
	using StringSplitter = TextUtils_StringSplitter;
	using SimpleStringSplitter = TextUtils_SimpleStringSplitter;
	using EllipsizeCallback = TextUtils_EllipsizeCallback;

	static jint CAP_MODE_CHARACTERS() { return get_static_field<"CAP_MODE_CHARACTERS", jint>(); }
	static jint CAP_MODE_SENTENCES() { return get_static_field<"CAP_MODE_SENTENCES", jint>(); }
	static jint CAP_MODE_WORDS() { return get_static_field<"CAP_MODE_WORDS", jint>(); }
	static jni::ref<android::os::Parcelable_Creator> CHAR_SEQUENCE_CREATOR() { return get_static_field<"CHAR_SEQUENCE_CREATOR", jni::ref<android::os::Parcelable_Creator>>(); }

	static void getChars(jni::ref<java::lang::CharSequence> s, jint start, jint end, jni::ref<jni::array<jchar>> dest, jint destoff) { return call_static_method<"getChars", void>(s, start, end, dest, destoff); }
	static jint indexOf(jni::ref<java::lang::CharSequence> s, jchar ch) { return call_static_method<"indexOf", jint>(s, ch); }
	static jint indexOf(jni::ref<java::lang::CharSequence> s, jchar ch, jint start) { return call_static_method<"indexOf", jint>(s, ch, start); }
	static jint indexOf(jni::ref<java::lang::CharSequence> s, jchar ch, jint start, jint end) { return call_static_method<"indexOf", jint>(s, ch, start, end); }
	static jint lastIndexOf(jni::ref<java::lang::CharSequence> s, jchar ch) { return call_static_method<"lastIndexOf", jint>(s, ch); }
	static jint lastIndexOf(jni::ref<java::lang::CharSequence> s, jchar ch, jint last) { return call_static_method<"lastIndexOf", jint>(s, ch, last); }
	static jint lastIndexOf(jni::ref<java::lang::CharSequence> s, jchar ch, jint start, jint last) { return call_static_method<"lastIndexOf", jint>(s, ch, start, last); }
	static jint indexOf(jni::ref<java::lang::CharSequence> s, jni::ref<java::lang::CharSequence> needle) { return call_static_method<"indexOf", jint>(s, needle); }
	static jint indexOf(jni::ref<java::lang::CharSequence> s, jni::ref<java::lang::CharSequence> needle, jint start) { return call_static_method<"indexOf", jint>(s, needle, start); }
	static jint indexOf(jni::ref<java::lang::CharSequence> s, jni::ref<java::lang::CharSequence> needle, jint start, jint end) { return call_static_method<"indexOf", jint>(s, needle, start, end); }
	static jboolean regionMatches(jni::ref<java::lang::CharSequence> one, jint toffset, jni::ref<java::lang::CharSequence> two, jint ooffset, jint len) { return call_static_method<"regionMatches", jboolean>(one, toffset, two, ooffset, len); }
	static jni::ref<java::lang::String> substring(jni::ref<java::lang::CharSequence> source, jint start, jint end) { return call_static_method<"substring", jni::ref<java::lang::String>>(source, start, end); }
	static jni::ref<java::lang::String> join(jni::ref<java::lang::CharSequence> delimiter, jni::ref<jni::array<java::lang::Object>> tokens) { return call_static_method<"join", jni::ref<java::lang::String>>(delimiter, tokens); }
	static jni::ref<java::lang::String> join(jni::ref<java::lang::CharSequence> delimiter, jni::ref<java::lang::Iterable> tokens) { return call_static_method<"join", jni::ref<java::lang::String>>(delimiter, tokens); }
	static jni::ref<jni::array<java::lang::String>> split(jni::ref<java::lang::String> text, jni::ref<java::lang::String> expression) { return call_static_method<"split", jni::ref<jni::array<java::lang::String>>>(text, expression); }
	static jni::ref<jni::array<java::lang::String>> split(jni::ref<java::lang::String> text, jni::ref<java::util::regex::Pattern> pattern) { return call_static_method<"split", jni::ref<jni::array<java::lang::String>>>(text, pattern); }
	static jni::ref<java::lang::CharSequence> stringOrSpannedString(jni::ref<java::lang::CharSequence> source) { return call_static_method<"stringOrSpannedString", jni::ref<java::lang::CharSequence>>(source); }
	static jboolean isEmpty(jni::ref<java::lang::CharSequence> str) { return call_static_method<"isEmpty", jboolean>(str); }
	static jint getTrimmedLength(jni::ref<java::lang::CharSequence> s) { return call_static_method<"getTrimmedLength", jint>(s); }
	static jboolean equals(jni::ref<java::lang::CharSequence> a, jni::ref<java::lang::CharSequence> b) { return call_static_method<"equals", jboolean>(a, b); }
	static jni::ref<java::lang::CharSequence> getReverse(jni::ref<java::lang::CharSequence> source, jint start, jint end) { return call_static_method<"getReverse", jni::ref<java::lang::CharSequence>>(source, start, end); }
	static void writeToParcel(jni::ref<java::lang::CharSequence> cs, jni::ref<android::os::Parcel> p, jint parcelableFlags) { return call_static_method<"writeToParcel", void>(cs, p, parcelableFlags); }
	static void dumpSpans(jni::ref<java::lang::CharSequence> cs, jni::ref<android::util::Printer> printer, jni::ref<java::lang::String> prefix) { return call_static_method<"dumpSpans", void>(cs, printer, prefix); }
	static jni::ref<java::lang::CharSequence> replace(jni::ref<java::lang::CharSequence> template_, jni::ref<jni::array<java::lang::String>> sources, jni::ref<jni::array<java::lang::CharSequence>> destinations) { return call_static_method<"replace", jni::ref<java::lang::CharSequence>>(template_, sources, destinations); }
	static jni::ref<java::lang::CharSequence> expandTemplate(jni::ref<java::lang::CharSequence> template_, jni::ref<jni::array<java::lang::CharSequence>> values) { return call_static_method<"expandTemplate", jni::ref<java::lang::CharSequence>>(template_, values); }
	static jint getOffsetBefore(jni::ref<java::lang::CharSequence> text, jint offset) { return call_static_method<"getOffsetBefore", jint>(text, offset); }
	static jint getOffsetAfter(jni::ref<java::lang::CharSequence> text, jint offset) { return call_static_method<"getOffsetAfter", jint>(text, offset); }
	static void copySpansFrom(jni::ref<android::text::Spanned> source, jint start, jint end, jni::ref<java::lang::Class> kind, jni::ref<android::text::Spannable> dest, jint destoff) { return call_static_method<"copySpansFrom", void>(source, start, end, kind, dest, destoff); }
	static jni::ref<java::lang::CharSequence> ellipsize(jni::ref<java::lang::CharSequence> text, jni::ref<android::text::TextPaint> p, jfloat avail, jni::ref<android::text::TextUtils_TruncateAt> where) { return call_static_method<"ellipsize", jni::ref<java::lang::CharSequence>>(text, p, avail, where); }
	static jni::ref<java::lang::CharSequence> ellipsize(jni::ref<java::lang::CharSequence> text, jni::ref<android::text::TextPaint> paint, jfloat avail, jni::ref<android::text::TextUtils_TruncateAt> where, jboolean preserveLength, jni::ref<android::text::TextUtils_EllipsizeCallback> callback) { return call_static_method<"ellipsize", jni::ref<java::lang::CharSequence>>(text, paint, avail, where, preserveLength, callback); }
	static jni::ref<java::lang::CharSequence> listEllipsize(jni::ref<android::content::Context> context, jni::ref<java::util::List> elements, jni::ref<java::lang::String> separator, jni::ref<android::text::TextPaint> paint, jfloat avail, jint moreId) { return call_static_method<"listEllipsize", jni::ref<java::lang::CharSequence>>(context, elements, separator, paint, avail, moreId); }
	static jni::ref<java::lang::CharSequence> commaEllipsize(jni::ref<java::lang::CharSequence> text, jni::ref<android::text::TextPaint> p, jfloat avail, jni::ref<java::lang::String> oneMore, jni::ref<java::lang::String> more) { return call_static_method<"commaEllipsize", jni::ref<java::lang::CharSequence>>(text, p, avail, oneMore, more); }
	static jni::ref<java::lang::String> htmlEncode(jni::ref<java::lang::String> s) { return call_static_method<"htmlEncode", jni::ref<java::lang::String>>(s); }
	static jni::ref<java::lang::CharSequence> concat(jni::ref<jni::array<java::lang::CharSequence>> text) { return call_static_method<"concat", jni::ref<java::lang::CharSequence>>(text); }
	static jboolean isGraphic(jni::ref<java::lang::CharSequence> str) { return call_static_method<"isGraphic", jboolean>(str); }
	static jboolean isGraphic(jchar c) { return call_static_method<"isGraphic", jboolean>(c); }
	static jboolean isDigitsOnly(jni::ref<java::lang::CharSequence> str) { return call_static_method<"isDigitsOnly", jboolean>(str); }
	static jint getCapsMode(jni::ref<java::lang::CharSequence> cs, jint off, jint reqModes) { return call_static_method<"getCapsMode", jint>(cs, off, reqModes); }
	static jint getLayoutDirectionFromLocale(jni::ref<java::util::Locale> locale) { return call_static_method<"getLayoutDirectionFromLocale", jint>(locale); }

protected:

	TextUtils(handle_type h) : base_(h) {}

};

} // namespace scapix::java_api

#include <scapix/jni/java_api/macros_pop.h>

#endif // SCAPIX_JAVA_API_ANDROID_TEXT_TEXTUTILS
