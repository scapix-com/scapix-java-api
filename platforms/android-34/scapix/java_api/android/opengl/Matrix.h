// Generated by Scapix Java API 2.0
// https://www.scapix.com

#include <scapix/java_api/java/lang/Object.h>

#ifndef SCAPIX_JAVA_API_ANDROID_OPENGL_MATRIX_FWD
#define SCAPIX_JAVA_API_ANDROID_OPENGL_MATRIX_FWD

#include <scapix/jni/java_api/macros_push.h>

namespace scapix::java_api::android::opengl { class Matrix; }

template<>
struct scapix::jni::object_traits<scapix::java_api::android::opengl::Matrix>
{
	static constexpr fixed_string class_name = "android/opengl/Matrix";
	using base_classes = std::tuple<scapix::java_api::java::lang::Object>;
};

#include <scapix/jni/java_api/macros_pop.h>

#endif // SCAPIX_JAVA_API_ANDROID_OPENGL_MATRIX_FWD

#if !defined(SCAPIX_JAVA_API_FWD) && !defined(SCAPIX_JAVA_API_ANDROID_OPENGL_MATRIX)
#define SCAPIX_JAVA_API_ANDROID_OPENGL_MATRIX

#include <scapix/jni/java_api/macros_push.h>

namespace scapix::java_api {

class android::opengl::Matrix : public jni::object_base<"android/opengl/Matrix",
	java::lang::Object>
{
public:

	static jni::ref<android::opengl::Matrix> new_object() { return base_::new_object(); }
	static void multiplyMM(jni::ref<jni::array<jfloat>> result, jint resultOffset, jni::ref<jni::array<jfloat>> lhs, jint lhsOffset, jni::ref<jni::array<jfloat>> rhs, jint rhsOffset) { return call_static_method<"multiplyMM", void>(result, resultOffset, lhs, lhsOffset, rhs, rhsOffset); }
	static void multiplyMV(jni::ref<jni::array<jfloat>> resultVec, jint resultVecOffset, jni::ref<jni::array<jfloat>> lhsMat, jint lhsMatOffset, jni::ref<jni::array<jfloat>> rhsVec, jint rhsVecOffset) { return call_static_method<"multiplyMV", void>(resultVec, resultVecOffset, lhsMat, lhsMatOffset, rhsVec, rhsVecOffset); }
	static void transposeM(jni::ref<jni::array<jfloat>> mTrans, jint mTransOffset, jni::ref<jni::array<jfloat>> m, jint mOffset) { return call_static_method<"transposeM", void>(mTrans, mTransOffset, m, mOffset); }
	static jboolean invertM(jni::ref<jni::array<jfloat>> mInv, jint mInvOffset, jni::ref<jni::array<jfloat>> m, jint mOffset) { return call_static_method<"invertM", jboolean>(mInv, mInvOffset, m, mOffset); }
	static void orthoM(jni::ref<jni::array<jfloat>> m, jint mOffset, jfloat left, jfloat right, jfloat bottom, jfloat top, jfloat near, jfloat far) { return call_static_method<"orthoM", void>(m, mOffset, left, right, bottom, top, near, far); }
	static void frustumM(jni::ref<jni::array<jfloat>> m, jint offset, jfloat left, jfloat right, jfloat bottom, jfloat top, jfloat near, jfloat far) { return call_static_method<"frustumM", void>(m, offset, left, right, bottom, top, near, far); }
	static void perspectiveM(jni::ref<jni::array<jfloat>> m, jint offset, jfloat fovy, jfloat aspect, jfloat zNear, jfloat zFar) { return call_static_method<"perspectiveM", void>(m, offset, fovy, aspect, zNear, zFar); }
	static jfloat length(jfloat x, jfloat y, jfloat z) { return call_static_method<"length", jfloat>(x, y, z); }
	static void setIdentityM(jni::ref<jni::array<jfloat>> sm, jint smOffset) { return call_static_method<"setIdentityM", void>(sm, smOffset); }
	static void scaleM(jni::ref<jni::array<jfloat>> sm, jint smOffset, jni::ref<jni::array<jfloat>> m, jint mOffset, jfloat x, jfloat y, jfloat z) { return call_static_method<"scaleM", void>(sm, smOffset, m, mOffset, x, y, z); }
	static void scaleM(jni::ref<jni::array<jfloat>> m, jint mOffset, jfloat x, jfloat y, jfloat z) { return call_static_method<"scaleM", void>(m, mOffset, x, y, z); }
	static void translateM(jni::ref<jni::array<jfloat>> tm, jint tmOffset, jni::ref<jni::array<jfloat>> m, jint mOffset, jfloat x, jfloat y, jfloat z) { return call_static_method<"translateM", void>(tm, tmOffset, m, mOffset, x, y, z); }
	static void translateM(jni::ref<jni::array<jfloat>> m, jint mOffset, jfloat x, jfloat y, jfloat z) { return call_static_method<"translateM", void>(m, mOffset, x, y, z); }
	static void rotateM(jni::ref<jni::array<jfloat>> rm, jint rmOffset, jni::ref<jni::array<jfloat>> m, jint mOffset, jfloat a, jfloat x, jfloat y, jfloat z) { return call_static_method<"rotateM", void>(rm, rmOffset, m, mOffset, a, x, y, z); }
	static void rotateM(jni::ref<jni::array<jfloat>> m, jint mOffset, jfloat a, jfloat x, jfloat y, jfloat z) { return call_static_method<"rotateM", void>(m, mOffset, a, x, y, z); }
	static void setRotateM(jni::ref<jni::array<jfloat>> rm, jint rmOffset, jfloat a, jfloat x, jfloat y, jfloat z) { return call_static_method<"setRotateM", void>(rm, rmOffset, a, x, y, z); }
	static void setRotateEulerM(jni::ref<jni::array<jfloat>> rm, jint rmOffset, jfloat x, jfloat y, jfloat z) { return call_static_method<"setRotateEulerM", void>(rm, rmOffset, x, y, z); }
	static void setRotateEulerM2(jni::ref<jni::array<jfloat>> rm, jint rmOffset, jfloat x, jfloat y, jfloat z) { return call_static_method<"setRotateEulerM2", void>(rm, rmOffset, x, y, z); }
	static void setLookAtM(jni::ref<jni::array<jfloat>> rm, jint rmOffset, jfloat eyeX, jfloat eyeY, jfloat eyeZ, jfloat centerX, jfloat centerY, jfloat centerZ, jfloat upX, jfloat upY, jfloat upZ) { return call_static_method<"setLookAtM", void>(rm, rmOffset, eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ); }

protected:

	Matrix(handle_type h) : base_(h) {}

};

} // namespace scapix::java_api

#include <scapix/jni/java_api/macros_pop.h>

#endif // SCAPIX_JAVA_API_ANDROID_OPENGL_MATRIX
